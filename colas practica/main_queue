# -*- coding: utf-8 -*-
"""
Created on Wed Mar 13 09:07:01 2024

@author: isabe
"""

from array_queue import ArrayQueue
import sys
import pandas


class Process():
    def __init__(self, process_id:str, user_id:int, process_type:str, expected_time:str, execution_time:int):
        """
        Create a Process instance.

        Parameters
        ----------
        process_id : str
            The unique identifier of the process.
        user_id : str
            The identifier for the user who initiated the process.
        process_type : str
            The type of the process (gpu or cpu)
        expected_time : str
            The expected time for the process to complete (short or long).
        execution_time : int
            The actual time, in practice, taken for the process to execute.
        """
        
        self._process_id = process_id
        self._user_id = user_id
        self._process_type = process_type
        self._expected_time = expected_time
        self._execution_time = int(execution_time)
        #tiempo en el que el proceso pasa al gestor de colas
        self._start_time = 0
        #tiempo en el que se empieza a ejecutar el proceso
        self._start_execution_time = 0
        self._penalty = False
    @property
    def process_id(self):
        """
        Gets the process identifier of the Process.
        
        Returns
        -------
        str
            The process identifier of the Process.
        """
        return self._process_id
    
    @process_id.setter
    def process_id(self, value: str):
        """
        Set the process identifier of the Process.
        
        Parameters
        ----------
        value : str 
            The new process identifier of the Process.
        
        Raises
        ------
        ValueError
            If the provided value is an empty string.
        """
        # Setter for the process_id
        if isinstance(value, str) and len(value) != 0:
            self._process_id = value
        else:
            raise ValueError("Process identifier must be an non empty string")
            
    @property
    def user_id(self):
        """
        Gets the user identifier of the Process.
        
        Returns
        -------
        str
            The user identifier of the Process.
        """
        return self._user_id
    
    @user_id.setter
    def user_id(self, value: str):
        """
        Set the user identifier of the Process.
        
        Parameters
        ----------
        value : str 
            The new user identifier of the Process.
        
        Raises
        ------
        ValueError
            If the provided value is an empty string.
        """
        # Setter for the level
        if isinstance(value, str) and len(value) != 0:
            self._user_id = value
        else:
            raise ValueError("User identifier must be an non empty string")
        
    @property
    def process_type(self):
        """
        Gets the type of the Process.
        
        Returns
        -------
        str
            The type of the Process.
        """
        return self._process_type
    
    @process_type.setter
    def process_type(self, value: str):
        """
        Set the type of the Process.
        
        Parameters
        ----------
        value : str 
            The new type of the Process.
        
        Raises
        ------
        ValueError
            If the provided value is an empty string or is neither 'gpu' nor 'cpu'.
        """
        # Setter for the level
        if isinstance(value, str) and len(value) != 0 and (value in ('gpu', 'cpu')):
            self._process_type = value
        else:
            raise ValueError("Process type must be an non empty string and must be either 'gpu' or 'cpu' ")
    
    @property
    def expected_time(self):
        """
        Gets the expected completion time of the Process.
        
        Returns
        -------
        str
            The expected completion time of the Process.
        """
        return self._expected_time
    
    @expected_time.setter
    def expected_time(self, value: str):
        """
        Set the expected completion time of the Process.
        
        Parameters
        ----------
        value : str 
            The new expected completion time of the Process.
        
        Raises
        ------
        ValueError
            If the provided value is an empty string or is neither 'long' nor 'short'.
        """
        # Setter for the level
        if isinstance(value, str) and len(value) != 0 and (value in ('long', 'short')):
            self._expected_time = value
        else:
            raise ValueError("Process expected time must be an non empty string and must be either 'long' or 'short' ")

    @property
    def execution_time(self):
        """
        Gets the actual execution completion time of the Process. 
        
        Returns
        -------
        int
            The time taken for the Process to execute.
        """
        return self._execution_time
    
    @execution_time.setter
    def execution_time(self, value: str):
        """
        Set the execution completion time of the Process
        
        Parameters
        ----------
        value : int  
            The new execution completion time of the Process.
        
        Raises
        ------
        ValueError
            If the provided value is not a positive integer.
        """
        # Setter for the level
        if isinstance(value, int) and value >= 0:
            self._execution_time = value
        else:
            raise ValueError("Process execution time must be an positive integer")
    
def create_processes(text: str) -> tuple:
    #diccionario con los usuarios, indica si tienen penalización activa
    user_dic ={}
    #crear cola de registros
    register_queue = ArrayQueue()
    processes = text.split("\n")
    
    for line in processes:
        process_id, user_id, process_type, expected_time, execution_time = line.split()
        register = Process(process_id, user_id, process_type, expected_time, execution_time)
        register_queue.enqueue(register)
        
        if not user_id in user_dic.keys():
            user_dic[user_id]=False 
            
    return register_queue, user_dic

def register_managing(register_queue:ArrayQueue, user_dic:dict):
    #lista con el número de procesos por usuario que tienen penalización
    processes_list = []
    #lista con el tiempo medio de estancia en las colas de ejecución
    stay_time = []
    cpushort_queue, cpulong_queue, gpushort_queue, gpulong_queue = ArrayQueue(), ArrayQueue(), ArrayQueue(), ArrayQueue()
    cnt=0
    queue_manager = QueueManager({"cpushort": cpushort_queue, "cpulong": cpulong_queue, "gpushort": gpushort_queue, "gpulong": gpulong_queue})
    
    while not register_queue.is_empty() or not check_stop_executing(queue_manager):
        cnt += 1
        if not register_queue.is_empty():
            next_process = register_queue.dequeue()
            next_process._start_time= cnt
            #se añade el proceso a su cola de ejecución correspondiente
            queue_manager.add_process(next_process)
            print(f"Process added to execution queue: <{cnt}><{next_process._process_id}><{next_process._user_id}> <{next_process._process_type}><{next_process._expected_time}>\n")
        queue_manager.execute_process(cnt, user_dic, stay_time, processes_list)
        
    
    print(stay_time)
    print(processes_list)
    queue_manager.pandas(processes_list, stay_time )
    
    
def check_stop_executing(queue_manager: "QueueManager"):
    for queue in queue_manager._queues.values():
        if not queue.is_empty():
            return False
    for process in queue_manager._executing_process.values():
        if process != None:
            return False
    return True
        

class QueueManager:
    """
    Creates managers for queues and the execution of containing processes.
    
    Parameters
    ----------
    queue_list : list
        List with the queues that need to be managed (cpulong, cpushort, gpulong, gpushort)
    executing_process : list
        List of processes that are being executed from each of the managed queues
    
    Methods 
    ------- 
    add_process(process: Process) -> None:
        Add the process to its corresponding execution queue from the list of managed queues.
        
    def execute_process(cnt:int, user_dic:dict, stay_time:list, processes_list:list) -> int:
        It handles the execution of processes from the managed queues, controlling penalties.
    """
    def __init__(self, queues:dict, executing_process={"cpushort": None, "cpulong": None, "gpushort": None, "gpulong": None}):
        """
        Create a QueueManager instance.
        
        Parameters
        ----------
        queue_list : list
            List of the queues that need to be managed (cpulong, cpushort, gpulong, gpushort)
        executing_process : list
            List of processes that are being executed from each of the managed queues
        """
        self._queues = queues
        self._executing_process = executing_process
        
    @property
    def queues(self):
        """
        Gets the dictionary of queues that will be managed.
        
        Returns
        -------
        dict
            Dictionary of managed queues.
        """
        return self._queues
    
    @queues.setter
    def queues(self, value: dict):
        """
        Set the dictionary of managed queues.
        
        Parameters
        ----------
        value : dict 
            The new expected dictionary of managed queues.
        
        Raises
        ------
        ValueError
            If the provided value is not a list of queues.
        """
        # Setter for the level
        if isinstance(value, dict):
            self._queues = value
        else:
            raise ValueError("queues must be a dictionary")
        for queue in self._queues:
            if not isinstance(queue, ArrayQueue):
                raise TypeError("Elements of queues dictionary must be queues")
        
    @property
    def executing_process(self):
        """
        Gets the dictionary of running processes for each of the managed queues.
        
        Returns
        -------
        list
            The dictionary of running processes for each of the managed queues.
        """
        return self._executing_process
    
    @executing_process.setter
    def executing_process(self, value: dict):
        """
        Set the list of running processes for each of the managed queues.
        
        Parameters
        ----------
        value : list 
            The new list of running processes for each of the managed queues.
        
        Raises
        ------
        ValueError
            If the provided value is not a list of Process.
        """
        # Setter for the level
        if isinstance(value, dict):
            self._executing_process = value
        else:
            raise ValueError("executing_process must be a dictionary")
        for process in self._executing_process:
            if not (isinstance(process, Process) or Process==None):
                raise TypeError("Elements of executing_process dictionary must be Process or None")
                
        
    def add_process(self, process: Process):
        """
        Add the given process to the execution queue of the manager's queue list corresponding to its process type and expected time.
        
        Parameters
        ----------
        process : Process
            Process we want to insert into its corresponding execution queue.
        
        Returns
        -------
        None
        """
        #cambiar utilizando diccionarios
        if process._process_type == "cpu":
            if process._expected_time == "short":
                self._queues["cpushort"].enqueue(process)
            elif process._expected_time == "long":
                self._queues["cpulong"].enqueue(process)
        elif process._process_type == "gpu":
            if process._expected_time == "short":
                self._queues["gpushort"].enqueue(process)
            elif process._expected_time == "long":
                self._queues["gpulong"].enqueue(process)
                
                
    def execute_process(self, cnt:int, user_dic:dict, stay_time:list, processes_list:list):
        """
        Esta función se encarga de gestionar los procesos en ejecución en cada momento (según el contador). Emplea la lista
        de procesos en ejecucion (executing_process) que indica para cada una de las colas que gestiona que proceso está e
        ejecutándose en un momento en concreto (cnt). Si no hay ningún proceso ejecutándose (None) se saca el proceso que está de primero 
        en la cola correspondiente. En este momento se calcula el tiempo medio de estancai en la cola de ejecución. Si el expected time es 
        short se comprueba en el diccionario de usuarios que el usuario de ese proceso cuente con penalización. Si es cierto se pasa el proceso 
        al final de la cola long de su tipo (process_type) y se desactiva la penalización. Si el proceso ejecutándose no es None y ya ha pasado su
        execution_time si quita de la lista de procesos de ejecución cambiándolo a None. Además si su tipo es short comprueba que su execution_time
        sea menor que 5, y si esto no se cumple se activa la penalización de su usario.
        
        
        Parameters
        ----------
        cnt : int
         
        Returns
        -------
        None
        """
        for process_type in self.executing_process:
            #iterador para la lista de procesos en ejecución
            if not self._queues[process_type].is_empty():
                #mientras la cola de ese proceso no este vacía
                if self._executing_process[process_type] == None:
                    #si no hay proceso ejecutándose de esa cola, sale el primero de la cola y empieza a ejecutarse
                    next_process = self._queues[process_type].dequeue()
                    print(cnt,next_process._start_time, f"{next_process._process_type}{next_process._expected_time}")
                    
                    #aplicar penalización del usuario
                    if next_process._expected_time == "short" and user_dic[next_process._user_id] == True:
                        self.execute_penalty(cnt, next_process, user_dic)
                    else:
                        #si no es el caso de la penalización, se añade a la lista de procesos ejecutándose
                        self._executing_process[process_type] = next_process
                        next_process._start_execution_time = cnt
                        avg_staytime = cnt - next_process._start_time
                        stay_time.append([next_process._process_type, next_process._expected_time, avg_staytime, next_process._process_id])
                        
            p = self._executing_process[process_type]
            if p != None and cnt >= p._execution_time + p._start_execution_time:
                print(cnt, p._execution_time, p._start_execution_time)
                #caso de penalización si es short y t>5
                if p._expected_time=="short" and (p._execution_time > 5) and not p._penalty:
                    user_dic[p._user_id] = True
                    print(f"Penalización activa: <{cnt}>><{p._user_id}>\n")
                if p._penalty:
                    processes_list.append([p._user_id, 1])
                else:
                    processes_list.append([p._user_id, 0])
                print(f"Proceso terminado: <{cnt}><{p._process_id}><{p._user_id}> <{p._process_type}><{p._expected_time}><{p._start_time}><{p._start_execution_time}><{p._execution_time}>\n")      
                    
                #se borra de la lista de procesos en ejecución, ya se ha ejecutado
                self._executing_process[process_type] = None
      
            
    def execute_penalty(self, cnt:int, process:Process, user_dic:dict):
        if process._process_type == "cpu":
            self._queues["cpulong"].enqueue(process)
        else:
            self._queues["gpulong"].enqueue(process)
        process._penalty = True
        user_dic[process._user_id] = False
        print(f"Penalización aplicada: <{cnt}><{process._process_id}><{process._user_id}>\n")
   


   
    def pandas(self, process_list:list, stay_time:list): 
        data = pandas.DataFrame(process_list, columns=["User_id","Penalties"])
        print(data)
        group_col = "User_id"
        target_col = "Penalties" 
        single_stats = data.groupby(group_col).agg({target_col :["mean"]})
        print('\n', "*"*37, '\n', "          Average Penalties      ", '\n',  "*"*37 )
        print (single_stats)
        
        data = pandas.DataFrame(stay_time, columns=["Type","Time", "Average stay time", "id_process"])
        group_col = ["Type","Time"]
        target_col = "Average stay time" 
        stats = data.groupby(group_col).agg({target_col :["mean"]})
        print('\n', "*"*37, '\n', "          Average stay time      ", '\n',  "*"*37 )
        print (stats)

    
def main():
    """
    The main function that reads from a file and starts the simulation.
    """

    with open(sys.argv[1]) as f:
        process_text = f.read().strip()
        register_queue, user_dic = create_processes(process_text)
        register_managing(register_queue, user_dic)

if __name__ == '__main__':
    main()
